# 函数式编程

1. 来源

- 函数式编程来源于 λ (Lambda x=>x*2) 演算
- 范畴
  - 将范畴想象成一个容器，值和值的变形关系 （这种关系就是函数的定义）
  - 本质上，函数式编程只是范畴论的运算方法， 是一种数学方法
  - 为什么函数式编程要求函数必须是纯的，不能有副作用
    - 因为它是一种数学运算，原始目的就是为了求职，不作它用，否则就无法满足函数运算法则了
<a name="olmJX"></a>
# 2. 主旨

- 函数式编程不是用函数来编程，也不是传统的面向过程编程，主旨在于将复杂的函数符和成简单的函数。运算过程尽量写成一系列嵌套的函数调用
- **函数对外部状态对依赖是造成系统复杂性大大提高的主要原因**
- 三大特性
  - 声明式
  - 不可变
  - 没有副作用
- 副作用
  - 定义
    - 在函数中与函数作用域之外的一切事物有交互的就产生了副作用，比如读写文件， 在控制台打印语句，修改页面元素的css等操作
<a name="qua3z"></a>
# 3. javascript 是披着C外衣的lisp
<a name="82svE"></a>
# 4. 火热于React 的高阶函数


<a name="qwwYe"></a>
# 一. 函数是第一等公民

- 函数和其它数据类型一样，处于平等地位，可以赋值，也可以传递给另外的参数
<a name="6mnoa"></a>
# 二. 不可改变量。

- 在函数式编程中，我们通常理解的变量也被函数代替了，这里所说的变量是不能被修改的，所有的变量只能被修改一次
- 常用的函数式编程方法
  - map & reduce
<a name="RyfWf"></a>
### 一. 函数是第一等公民
<a name="LX1GT"></a>
### 二. 只用"表达式"，不用"语句"
<a name="bvt4J"></a>
### 三. 没有副作用
<a name="98qNl"></a>
### 四. 不修改状态
<a name="sKXSH"></a>
### 五. 引用透明（函数运行只靠参数）


<a name="8xVdM"></a>
# 三. 专业术语
<a name="v8KJL"></a>
## 纯函数

- Array.slice
- 对于相同的输入，一定会得到相同的输出
- 优点
  - 可以有效降低系统的复杂性
  - 可缓存性
- 缺点
  - 将依赖外部的变量硬编码在了函数中，导致可扩展性比较差，可用“柯里化”解决
- 幂等性
  - 幂等性是指函数执行无数次后还具有相同的结果
  - Math.abs(Math.abs(-42))
<a name="8zrMk"></a>
## 偏应用函数，函数的柯里化

- 传递给函数一部分参数来调用它，让他返回一个函数去处理剩下的参数
- 偏函数之所以偏，是因为它只能处理那些能与至少一个case语句匹配的输入，而不能处理所有可能的输入



```javascript
const partial = (fn, ...args) => (...moreArgs) => fn(...args, ...moreArgs)

const add3 = (a, b, c) => a+b+c;

const fivePlus = partial(add3, 2);
fivePlus(3, 4)
```

- 柯里化通过偏函数实现



```javascript
let checkage = min => num => num > min;
let checkage18 = checkage(18);
checkage18(17);
```

- 柯里化是一种“预加载”函数的方法，通过传递较少的参数来得到一个已经记住这些参数的新函数，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法
<a name="cNK6J"></a>
## 函数组合


```javascript
let first = arr => arr[0];
let reverse = arr => arr.reverse();
let compose = (fn1, fn2) => x => fn1(fn2(x));
let lastFn = compose(first, reverse);
lastFn([1,2,3,4]);
```


<a name="rBc5m"></a>
## Point Free

- 把一些对象只带的方法转化成纯函数，不要无意义的中间变量
- **简单说，Pointfree 就是运算过程抽象化，处理一个值，但是不提到这个值**。这样做有很多好处，它能够让代码更清晰和简练，更符合语义，更容易复用，测试也变得轻而易举。
- PointFree 的本质
  - Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。
- **不使用所要处理的值，只合成运算过程。**中文可以译作"无值"风格。
```javascript

let compose = (fn1, fn2) => x => fn1(fn2(x));
const toUpperCase = str => str.toUpperCase();
const split = str => str.split("");
let comp = compose(split, toUpperCase);
comp("abc def");
```
```javascript
var str = 'Lorem ipsum dolor sit amet consectetur adipiscing elit';

// 上面代码的另一种写法 使用ramdajs库
var getLongestWordLength = R.pipe(
  R.split(' '),
  R.map(R.length),
  R.reduce(R.max, 0)
);
```
<a name="rzWzO"></a>
## ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1123810/1587049400650-13a98f3d-c9d3-4c8a-a2b9-8d69132e4d77.png#align=left&display=inline&height=342&margin=%5Bobject%20Object%5D&name=image.png&originHeight=684&originWidth=750&size=160716&status=done&style=none&width=375)

- 现在要求是，找到用户 Scott 的所有未完成任务，并按到期日期升序排列。
```javascript
// 提取 tasks 属性
var SelectTasks = R.prop('tasks');

// 过滤出指定的用户
var filterMember = member => R.filter(
  R.propEq('username', member)
);

// 排除已经完成的任务
var excludeCompletedTasks = R.reject(R.propEq('complete', true));

// 选取指定属性
var selectFields = R.map(
  R.pick(['id', 'dueDate', 'title', 'priority'])
);

// 按照到期日期排序
var sortByDueDate = R.sortBy(R.prop('dueDate'));

// 合成函数
var getIncompleteTaskSummaries = function(membername) {
  return fetchData().then(
    R.pipe(
      SelectTasks,
      filterMember(membername),
      excludeCompletedTasks,
      selectFields,
      sortByDueDate,
    )
  );
};
```

<a name="0ig7o"></a>
## 声明式与命令式代码

- 命令式
  - 一步一步的指示计算机去干嘛
- 声明式
  - 通过写表达式的方式来声明我们想干嘛



```javascript
// 命令式
let CEOs = [];
for(var i = 0; i < companies.length; i++)
  CEOs.push(companies[i].CEO) 
}
//声明式
let CEOs = companies.map(c => c.CEO);
```

- 声明式的代码是函数式编程的一个明显的好处，对于没有副作用的纯函数，我们不需要考虑这些函数内部是如何实现的，专注于业务代码，优化代码时，目光只需要集中在这些坚固稳定的函数内部即可
<a name="SKB7q"></a>
## 惰性求值，惰性函数，惰性链

- 指令式方式编程中，每一个函数都有可能修改外部的变量，所以必须顺序执行

<br />
<a name="zIERJ"></a>
# 更加专业术语
<a name="Rm5B9"></a>
## 高阶函数

- 把函数当参数，封装传入的函数，返回传入的函数，以达到更高程度的抽象



```javascript
const add = (a, b) => a + b;
function fn = (f, arr) => f(...arr);
fn(add, [1, 2]);
```


<a name="rqi8E"></a>
## 尾调用优化PTC

- 指函数内部的最后一个动作（最后一步）是函数调用
- 通过尾递归优化，js代码在生成机器码的时候，将向while看齐，也就是同时拥有数学表达能力和while的效能
- 按道理尾递归调用永远都是更新当前的栈帧，这样就完全避免了暴栈的危险，但是现在的浏览器并未完全支持
  - 原因
    - 在引擎层面消除递归是一个隐式行为
    - 堆栈信息丢失了，开发者难以调试
  - 可以手动写生while循环
<a name="qBUZB"></a>
## 闭包


```javascript
function makePowerFn(power){
	function powerFn(base){
  	return Math.pow(base, power)
  }
  return powerFn;
}

let square = makePowerFn(2);
square(3);
// 外层函数执行完毕，栈上的调用帧被释放了，但是堆上的作用域并不被释放，因此power以及可以被powerFn函数访问

```


<a name="oO5tx"></a>
## 容器和Funtor

- 函子
  - 用于将一个范畴转换为另一个范畴
  - 一种数据类型
  - 是基本的运算单位和功能单位
  - 是一个范畴和容器，包含了值和变形关系，特殊的是它可以将变形关系作用于每一个值，将档期容器变形成为另一个容器
  - 遵守一些特定规则的容器类型
  - 是一个对函数调用的抽象，赋予容器自己去调用函数的能力，让容器自己来运行函数，这样容器就可以自由的选择何时何地如何操作这个函数，以至于拥有惰性求值，错误处理，异步调用的牛掰的特性
- 函子的实现
  - 任何具有map方法的数据结构都可以当作函子的实现



```javascript
let Container = function(x){
	this._value = x;
}
Container.of = x => new Container(x); // 函式编程通过of方法生成新的容器，不显示的使用new操作符（因为它更像是面向对象编程）
// 函子的标志就是具有map方法
Container.prototype.map = f => Container.of(f(this._value))

Container.of(3)
	.map(x=>x+1)
	.map(x=>"result is" + x);


//ES6
class Functor{ 
	constructor(val){
  	this.val = val;
  }
  
  map(f){
  	return new Functor(f(this.val))
  }
}

let instance = new Functor(2);
let instance1 = instance.map(function(x){
	return x + 2;
})
console.log(instance1); // Functor {val: 4}
// 函数式编程里面的运算都是通过函子完成的，即运算不直接针对值，而是针对这个值的容器--函子
// map方法是函子的对外接口， 传入的函数就是运算符，通过map这个接口接入容器，引发容器里面值的变形
```

- **学习函数式编程，实际上就是学习函子的各种运算。由
于可以把运算方法封装在函子里面，所以又衍生出各种不同类
型的函子，有多少种运算，就有多少种函子。函数式编程就变
成了运用不同的函子，解决实际问题。**



				
			
		
	
<a name="sccAz"></a>
## maybe函子

- 函子接受各种参数，处理容器内部的值，但，如果函数内部的值是一个空值，但是外部的函数不一定具有处理空值的能力，如果传入空值，就会出错



```javascript
class Maybe extends Functor{
  constructor(val){
  	this.val = val;
  }
	map(f){
  	return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); // 要注意始终都要返回一个函子而不是一个值
  }
}
Maybe.of = val => new Maybe(val);
Maybe.of(null).map(str=>str.toUpperCase())
// Maybe {val: null}




// 完整版
var Maybe = function(x) { this.__value = x;
}
Maybe.of = function(x) {
	return new Maybe(x); 
}
Maybe.prototype.map = function(f) {
	return this.isNothing() ? Maybe.of(null) : Maybe.of(f(this.__value));
}
Maybe.prototype.isNothing = function() {
	return (this.__value === null || this.__value === undefined); 
}
//新的容器我们称之为 Maybe(原型来自于Haskell)

// 继承补充
// 子类只会继承父类原型链上的方法，不会继承静态方法（静态属性笔记特殊）
// 实例上不会继承类通过static声明的静态属性，非static的可以继承， 子类会继承通过static声明的静态属性和方法，
// 但是非static 的不行必须要该类的实例可以继承


// 静态方法不需要实例化就可以使用，原型方法必须实例化才可以使用
```


<a name="8nT6y"></a>
## 错误处理，Either，AP
<a name="wDI0f"></a>
## IO

<br />
<br />中间件<br />
<br />特点：抽象抽象抽象<br />对象：封装继承多态<br />
<br />方法 vs 函数<br />函数典型：map<br />方法很sb，函数是抽象<br />高阶函数

- 一等公民
- 以函数作为参数
- 以一个函数作为返回结果

尾调用优化

- 传统递归容易崩，有很大的缺陷


<br />v8 不能合并帧的原因是错误处理不能准确定位<br />浏览器不支持尾递归<br />函子不能自创<br />函子是一个实现呢map契约的接口<br />

<a name="PceO8"></a>
# 数据类型

- 数据类型就是对值对一种封装，不仅包括值本身，也包括相关属性和方法， 理解为一个数据类型对实例：包含值和context
- 函数也是一种数据类型， 运算实际上就是数据类型之间的运算， 函数的输入和输出都是数据类型
<a name="sb6I3"></a>
# Manad

- manad 就是一种设计模式，表示将一个运算过程，通过函数拆解成互相链接的多个步骤，你只要提供下一步运算所需的函数，整个运算就会自动进行下去。
- Promise 就是一种manad
- 作用
  - manad 让我们避开了嵌套地狱，可以进行深度嵌套的函数式编程，比如IO和其它异步任务
- 流行的函数式编程的库
  - RXJS
    - Function Reactive Programming 函数响应式编程
    - 所有的外部事件都被视为一种事件流
    - 把副作用问题推给了订阅者来解决
```javascript
var clicks = Rx.Observable
.fromEvent(document, 'click')
.bufferCount(2)
.subscribe(x => console.log(x)); // 打印出前2次点击事件
```
<a name="cifFs"></a>
## cycleJS

  - 基于RxJS，同reactJS，加入了virtualDom，组件，容器的支持
```javascript
function main(sources) { 
  const sinks = {
    DOM: sources.DOM.select('input').events('click') 
    .map(ev => ev.target.checked)
    .startWith(false)
    .map(toggled =>
    <div>
    <input type="checkbox" /> Toggle
    </div> )
    };
    return sinks; 
}
const drivers = {
DOM: makeDOMDriver('#app')
};
run(main, drivers);
```
<a name="KnCpR"></a>
## lodashJS，Lazy

  - lodash是一个具有一致接口、模块化、高性能等特性的JavaScript工
具库，是underscore.js的fork，其最初目标也是“一致的跨浏览器行
为。。。，并改善性能”。
lodash采用延迟计算，意味着我们的链式方法在显式或者隐式的
value()调用之前是不会执行的，因此lodash可以进行shortcut(捷
径) fusion(融合)这样的优化，通过合并链式大大降低迭代的次
数，从而大大提升其执行性能。
就如同jQuery在全部函数前加全局的$一样，lodash使用全局的_来
提供对工具的快速访问。

				
			
		
	
<a name="zMgRb"></a>
## underscoreJS

  - Underscore 是一个 JavaScript 工具库，它提供了一整套函数式编程
的实用功能，但是没有扩展任何 JavaScript 内置对象。 他解决了
这个问题:“如果我面对一个空白的 HTML 页面，并希望立即开始
工作，我需要什么?” 他弥补了 jQuery 没有实现的功能，同时又
是 Backbone 必不可少的部分。Underscore 提供了100多个函数，包括常用的:map、filter、invoke
— 当然还有更多专业的辅助函数，如:函数绑定、JavaScript 模板
功能、创建快速索引、强类型相等测试等等。
<a name="CAYT7"></a>
## ramdaJS

- ramda里面的提供的函数全部都是curry的 意味着函数没有默认参 数可选参数从而减轻认知函数的难度。
- **ramda推崇pointfree简单的说是使用简单函数组合实现一个复杂 功能**，而不是单独写一个函数操作临时变量。
- ramda有个非常好用的参数占位符 R._ 大大减轻了函数在pointfree 过程中参数位置的问题



<a name="0aehj"></a>
# 实际应用场景

- 易调试
- 热部署
- 并发
<a name="Sz3TS"></a>
# 单元测试

- 函数式编程非常易于单元测试，因为每个函数都是没有副作用的，唯一影响结果的因素就是参数
<a name="H7bGv"></a>
# 总结

- 函数式编程不应被视为灵丹妙药。相反，它应
该被视为我们现有工具箱的一个很自然的补充
—— 它带来了更高的可组合性，灵活性以及容错
性。现代的JavaScript库已经开始尝试拥抱函数式编
程的概念以获取这些优势。**Redux 作为一种 FLUX
的变种实现，核心理念也是状态机和函数式编程。**<br />
- 软件工程上讲『没有银弹』，函数式编程同样也不是万能的，它与烂大街的 OOP
一样，只是一种**编程范式**而已。很多实际应用中是很难用函数式去表达的，选择
OOP 亦或是其它编程范式或许会更简单。但我们要注意到函数式编程的核心理念，
如果说 **OOP 降低复杂度是靠良好的封装、继承、多态以及接口定义**的话，那么函
数式编程就是通过**纯函数以及它们的组合、柯里化、Functor** 等技术来降低系统复
杂度，而 React、Rxjs、Cycle.js 正是这种理念的代言。

				
			
		
	<br />				
			
		
	<br />				
			
		
	
